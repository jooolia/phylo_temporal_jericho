---
title: "32_Borcard_et_al_redo_Numerical_ecology_Chapter_4.Rmd"
author: "Julia Gustavsen"
date: "01/05/2015"
output: html_document
---
```{r, echo=FALSE}
## add in the functions for the pairs 

panel.cor <- function(x, y, method="pearson", digits=3, cex.cor=1.2, no.col=FALSE)
{
 usr <- par("usr"); on.exit(par(usr))
 par(usr = c(0, 1, 0, 1))
 r <- cor(x, y, method=method)
	ra <- cor.test(x, y, method=method)$p.value
	txt <- round(r, digits)
	prefix <- ""
	if(ra <= 0.1) prefix <- "."
	if(ra <= 0.05) prefix <- "*"
	if(ra <= 0.01) prefix <- "**"
	if(ra <= 0.001) prefix <- "***"
	if(no.col)
	{
		color <- 1
		if(r < 0) { if(ra <= 0.001) sig <- 4 else sig <- 3 }
		else { if(ra <= 0.001) sig <- 2 else sig <- 1 }
	}
	else
	{
		sig <- 1
		if(ra <= 0.001) sig <- 2
		color <- 2
		if(r < 0) color <- 4
	}
	txt <- paste(txt, prefix, sep="\n")
	text(0.5, 0.5, txt, cex = cex.cor, font=sig, col=color)
}


## Put histograms on the diagonal
panel.hist <- function(x, no.col=FALSE, ...)
{
	usr <- par("usr"); on.exit(par(usr))
	par(usr = c(usr[1:2], 0, 1.5) )
	his <- hist(x, plot=FALSE)
	breaks <- his$breaks; nB <- length(breaks)
	y <- his$counts
	y <- y/max(y)
	if(no.col) rect(breaks[-nB], 0, breaks[-1], y, col="gray", ...)
	else rect(breaks[-nB], 0, breaks[-1], y, col="cyan", ...)
}


## Add black lowess curves to scatter plots
panel.smoothb <- function (x, y, col=par("col"), bg=NA, pch=par("pch"), 
	cex=1, col.smooth="black", span=2/3, iter=3, ...) 
{
	points(x, y, pch=pch, col=col, bg=bg, cex=cex)
	ok <- is.finite(x) & is.finite(y)
	if (any(ok)) 
	lines(stats::lowess(x[ok], y[ok], f=span, iter=iter), col=col.smooth, ...)
}
```

# Chapter 4 cluster analysis

different kinds of clustering: can be hard (either you are a or b) or can be fuzzy (you are somewhere between 0 and 1). 
-does not test a hypothesis, but brings out hidden aspects of the data.
## what does least-squares mean?
-type of regression analysis that tries to minimize the residuals to some sort of fitted line. 


```{r}
library(ade4)
library(vegan)
library(gclus)
library(cluster)
library(RColorBrewer)
library(labdsv)
library(ggplot2)
#library(mvpart) these were removed from CRAN
#library(MVPARTwrap) these were removed from CRAN
data (doubs)
spe <- doubs$fish
env <- doubs$env
spa <- doubs$xy
str(spe)
str(env)
str(spa)
#REmove empty site 8
spe <- spe[-8,]
env <- env[-8,]
spa <- spa[-8,]
```


## 4.3
### Single linkage agglomerative clustering

-aka nearest neighbour sorting
-can be difficult to interpret in terms of partitions, but gradients are revealed quite clearly. 


```{r}
## Compute matrix on species abundance data of chord distance amond sites followed by single linkage agglomerative clustering

spe.norm <- decostand(spe,"normalize") ## normalize species abundance table. 
spe.ch <- vegdist(spe.norm, "euc")
spe.ch.single <- hclust(spe.ch, method="single")

plot(spe.ch.single)
## hard to interpret 1,5,9

```

### 4.3.2 COmplete LInkage agglomerative clustering

aka furthest neighbour sorting
useful for identifying discontinuities in the data

```{r}
spe.ch.complete <- hclust(spe.ch, method="complete")
plot(spe.ch.complete)

library(ggdendro)
# basic option
ggdendrogram(spe.ch.complete)
# another option
ggdendrogram(spe.ch.complete, rotate = TRUE, size = 4, theme_dendro = FALSE, color = "tomato")
# Triangular lines

dendr <- dendro_data(spe.ch.complete, type="triangle") 
ggplot() + 
  geom_segment(data=segment(dendr), aes(x=x, y=y, xend=xend, yend=yend))+ geom_text(data = label(dendr), aes(x = x, 
    y = y, label = label), angle = 90, lineheight = 0)



```

## 4.4 Average agglomerative clustering

## kind of intermediate bewteen single and complete linkage
```{r}
## UPGMA clustering

spe.ch.UPGMA <- hclust(spe.ch, method="average")
plot(spe.ch.UPGMA)
summary(spe.ch.UPGMA)
## see weird reversals in this. Cna be interpreted but it seems difficult. 
spe.ch.centroid<- hclust(spe.ch, method="centroid")
plot(spe.ch.centroid)

## skipping ward's

spe.ch.ward <- hclust(spe.ch, method="ward.D")
plot(spe.ch.ward)
```

## 4.7 Interpreting and Comparing Hierachical Clustering results

### 4.7.2 Cophenetic Correlation

what are we looking for here?
-cophenetic distance between 2 objects in a dendogram is the distance where the objects become members of the same group. Distance up until they are members of the same group. 

```{r}
## cophenetic correlatoin
# single linkage

spe.ch.single.coph <- cophenetic(spe.ch.single)
cor(spe.ch, spe.ch.single.coph)

```

## Silhouette widths...

can help determine how many optimal clusters...

## interesting where they plot the groups along the river. Could I try this by date?

```{r}
#Optimal number of clusters according to Mantel statistic (pearson)

# Function to compute a binay distance matrix from gorups 

grpdist <- function(X)
 {
 require(cluster)
 gr <- as.data.frame(as.factor(X))
 distgr <- daisy(gr, "gower")
 distgr
 }

#Ran based on Ward clustering
kt <- data.frame(k=1:nrow(spe), r=0)

for (i in 2:(nrow(spe) - 1)){
 gr <- cutree(spe.ch.ward, i)
 distgr <- grpdist(gr)
 mt <- cor(spe.ch, distgr, method="pearson")
 kt[i,2] <- mt
}

kt
k.best <- which.max(kt$r)
#Plot is then produced by function plot.silhouette (cluster)
plot(kt$k, kt$r, type="h", main="Mantel-optimal number of clusters - Ward", xlab="k (number of groups)", ylab="Pearson's correlation")
axis(1, k.best, paste("Optimum", k.best,spe="\n"), col="red", font=2, col.axis="red")
points(k.best, max(kt$r), pch=16, col="red", cex=1.5)

```



Final plot
```{r}
## Chooose number of clusters
k <- k.best ## 13

cutg <- cutree(spe.ch.ward, k=k)
sil <- silhouette(cutg,spe.ch)
silo <- sortSilhouette(sil)
rownames(silo) <- row.names(spe)[attr(silo,"iOrd")]
plot(silo, main="Silhouette plot-Chord - Ward", cex.names=0.8, col=cutg+1, nmax.lab=100)


spe.chwo <- reorder.hclust(spe.ch.ward, spe.ch)

## plot reorder dendrograms with group labels
plot(spe.chwo, hang=-1, xlab="13 groups", sub="", ylab="Height", main="Chord-Ward(reordered)", label=cutree(spe.chwo, k=k))
rect.hclust(spe.chwo, k=k)



```


Spatial
```{r}
plot(spa, asp=1, type="n", main="Fourd Ward Groups", xlab="x coordinate (km)", ylab="y coordinate (km)")
lines(spa, col="light blue")
## add the four groups
spebc.ward.g <- cutree(spe.ch.ward, k)
grw <- spebc.ward.g
k <- length(levels(factor(grw)))
for (i in 1:k){
 points(spa[grw==i, 1], spa[grw==i,2], pch=i+20, cex=3, col=i+1, bg=i+1)
}
text(spa, row.names(spa), cex=0.8, col="white", font=2)
legend("bottomright", paste("Group", 1:k), pch=1:k+20, col=2:(k+1), pt.bg=2:(k+1), pt.cex=2, bty="n")
```

skippped heatmaps...



K means...
linear method-not appropriate for raw species abundance with lots of zeroes.
-can use the normalized species abundance. And that goes in to the euclidean distance that is used in the k-means clustering


```{r}
spe.kmeans <- kmeans(spe.norm, centers=4, nstart=100)
table(spe.kmeans$cluster, spebc.ward.g)
spe.kmeans <- kmeans(spe.norm, centers=13, nstart=100)
table(spe.kmeans$cluster, spebc.ward.g)
```


```{r}
spe.KM.cascade <- cascadeKM(spe.norm, inf.gr=2, sup.gr=10, iter=100, criterion="ssi")
plot(spe.KM.cascade, sortg=TRUE)
summary(spe.KM.cascade)
spe.KM.cascade$results
spe.KM.cascade$partition



## Define the site clusters
## reorder site according to kmeans results
spe[order(spe.kmeans$cluster),]

ord.KM <- vegemite(spe,spe.kmeans$cluster) ## idsplays compact ordered community tables
spe[ord.KM$sites, ord.KM$species]

```

## 4.8.2

## 5 Skipped for now







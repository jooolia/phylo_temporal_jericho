---
title: "34_Borcard_et_al_redo_Numerical_ecology_Chapter_6"
author: "Julia Gustavsen"
date: "01/05/2015"
output: html_document
---

# 6 Canonical ordination

# 6. 3 Redundancy Analysis

Combines regression and PCA- principal component analysis
```{r}
library (ade4)
library (vegan)
library(gclus)
library(cluster)
library(RColorBrewer)
library(labdsv)
library(ggplot2)
 install.packages("packfor", repos="http://R-Forge.R-project.org")
library(MASS)
library(packfor)
library(ellipse)
library(FactoMineR)

data (doubs)
spe <- doubs$fish
env <- doubs$env
spa <- doubs$xy
str(spe)
str(env)
str(spa)
#REmove empty site 8
spe <- spe[-8,]
env <- env[-8,]
spa <- spa[-8,]
```


"If one wishes to extract structures of a data set that are related to structures in other data sets, and/or formally test statistical hypotheses about the significance of these relationships, canonical ordination is the way to go."
## 6.3 Redundancy analysis

RDA combines PCA and linear regression. 
-need matrix Y of centred response data (OTUs?)
-matrix X of centred (or standardized ) explanatory variables
-difference with unconstrained ordination-matrix of explanatory variables conditions that "weights", the orthogonality and the directions of the ordination axes.

- can test significance using permutations

```{r, echo=FALSE}
# Plot eigenvalues and percentages of variation of an ordination object
# Kaiser rule and broken stick model
# Usage:
# evplot(ev)
# where ev is a vector of eigenvalues

# License: GPL-2 
# Author: Francois Gillet, 25 August 2012

evplot <- function(ev)
{
 # Broken stick model (MacArthur 1957)
	n <- length(ev)
	bsm <- data.frame(j=seq(1:n), p=0)
	bsm$p[1] <- 1/n
	for (i in 2:n) bsm$p[i] <- bsm$p[i-1] + (1/(n + 1 - i))
	bsm$p <- 100*bsm$p/n
	# Plot eigenvalues and % of variation for each axis
	op <- par(mfrow=c(2,1))
	barplot(ev, main="Eigenvalues", col="bisque", las=2)
	abline(h=mean(ev), col="red")
	legend("topright", "Average eigenvalue", lwd=1, col=2, bty="n")
	barplot(t(cbind(100*ev/sum(ev), bsm$p[n:1])), beside=TRUE, 
		main="% variation", col=c("bisque",2), las=2)
	legend("topright", c("% eigenvalue", "Broken stick model"), 
		pch=15, col=c("bisque",2), bty="n")
	par(op)
}

# Function hcoplot()
# Reorder and plot dendrogram with colors for groups and legend
#
# Usage:
# hcoplot(tree = hclust.object, diss = dissimilarity.matrix, k = nb.clusters, 
# title = paste("Reordered dendrogram from",deparse(tree$call),sep="\n"))
#
# License: GPL-2 
# Author: Francois Gillet, 23 August 2012

"hcoplot" <- function(tree, diss, k, 
	title=paste("Reordered dendrogram from", deparse(tree$call), sep="\n"))
{
	require(gclus)
	gr <- cutree(tree, k=k)
	tor <- reorder.hclust(tree, diss)
	plot(tor, hang=-1, xlab=paste(length(gr),"sites"), sub=paste(k,"clusters"), 
		main=title)
	so <- gr[tor$order]
	gro <- numeric(k)
	for (i in 1:k)
	{
		gro[i] <- so[1]
		if (i<k) so <- so[so!=gro[i]]
	}
	rect.hclust(tor, k=k, border=gro+1, cluster=gr)
	legend("topright", paste("Cluster",1:k), pch=22, col=2:(k+1), bty="n")
}



```



```{r}
# set aside the das (distance from source) for later use
das <- env[,1]

# Remove das from env dataset
env <- env[,-1]

# Sloe into variable to see how this is handled in ordination


slo2 <- rep("very_steep",nrow(env))
slo2[env$slo <=quantile(env$slo)[4]] = "steep"
slo2[env$slo <=quantile(env$slo)[3]] = "moderate"
slo2[env$slo <=quantile(env$slo)[2]] = "low"

slo2 <- factor(slo2, levels=c("low", "moderate", "steep", "very_steep"))
table(slo2)
env2 <- env
env2$slo <- slo2

## Two subsetcs ot the explanatory variables

#Physiogrpahy(upstaem-downstream gradient)
envtopo <- env[,c(1:3)]
names(envtopo)

envchem <- env[,c(4:10)]
names(envchem)

## Hellinger transform the species dataset
spe.hel <- decostand(spe, "hellinger")

```

#### 6.3.2.2 RDA using vegan

the basic form of the RDA is
simpleRDA <- rda(Y,X,W)
Y-response matrix
X -matrix of explanatory variables
W-optional matrix of covariables
-call does not allow factors

Better to use the formula interface

formulaRDA <- rda(Y ~ var1+ factorA + var2*var3 + Condition(var4), data=XWdata)

Here Y is the response matrix
data is a data frame
-same formula as in lm

- I don't understand how you would come up with this...

```{r}
## RDA of Hellinger-transformed fish speices constrained by all of the environmental variables contained in env2 
## Observe the shortcut formula

spe.rda <- rda(spe.hel ~ ., env2)
## this uses all of the variables in env2 without having to name them

summary(spe.rda)
coef(spe.rda) ## gives canonical coefficients
```

Constrained variance- amount of variance on Y matrix explained by explanatory variables. 
-expressed as a proportion

-could also plot the residual axes and interpret the 

Now... how to interpret..
R^2 is biased. Any variable you include increases R^2.
So need to adjust R^2 using Ezekiel's formula


```{r}
## Unadjusted R^2 retrieved form the rda result
R2 <- RsquareAdj(spe.rda)$r.squared

# Adjusted R^2 retrieved from the rda object
R2adj <- RsquareAdj(spe.rda)$adj.r.squared

# see that the value is less now. 
```


Time to plot it
what is scaling 2???
```{r}
## Triplots of the rda results
## Scaling 1: distance triplot
plot(spe.rda, scaling=1, main="Triplot RDA spe.hel ~ env2 -scaling 1 - wa scores")
## add in arrows for speices
## note you have to specify the scaling
spe.sc <- scores(spe.rda, choices=1:2, scaling=1, display="sp")
arrows(0,0, spe.sc[,1], spe.sc[,2], length=0,lty=1, col="red")


## scaling 2
plot(spe.rda, scaling=2, main="Triplot RDA spe.hel ~ env2 -scaling 2 - wa scores")
## add in arrows for speices
spe2.sc <- scores(spe.rda, choices=1:2, scaling=2, display="sp")
arrows(0,0, spe2.sc[,1], spe2.sc[,2], length=0,lty=1, col="red")


```

Use the linear combinations of the environmental variables too
```{r}
## Scaling 1
plot(spe.rda, scaling=1, display=c("sp", "lc", "cn"),
     main="Triplot RDA spe.hel ~env2 - scaling 1 -1c scores")
arrows(0,0, spe.sc[,1], spe.sc[,2], length=0, lty=1, col="red")

#Scaling 2
plot(spe.rda,  display=c("sp", "lc", "cn"),
     main="Triplot RDA spe.hel ~env2 - scaling 2 -1c scores")
arrows(0,0, spe2.sc[,1], spe2.sc[,2], length=0, lty=1, col="red")
```


Need to use permutation tests on the rda
```{r}
## Global test of the RDA result
## step is the minimum number of permutations requested to see if F value is significant or not. 
anova.cca(spe.rda, step=1000)
## Tests of all canonical axes
anova.cca(spe.rda, by="axis", step=1000)
```
How to interpret this?


Can run the other tests like in pca
```{r}
## ok if I used spe.rda$CCA$eig then this would be the main axes. 
##how is this applying it to the residual axes?
spe.rda$CA$eig[spe.rda$CA$eig > mean(spe.rda$CA$eig)]

## so there is some remaining interesting variation. 


```

#### 6.3.2.5 Partial RDA

```{r}
## Partial RDA: effect of water chemistry, holding physiography constanct
#3 X and W may be seprarte tables of quant variables
spechem.physio <- rda(spe.hel, envchem, envtopo)
spechem.physio
summary(spechem.physio)

## another way to run this using the formula interface:
class(env)
spechem.physio2 <- rda(spe.hel ~ pH +har + pho+nit+amm+oxy+bdo+Condition(alt+slo+flo), data=env)
spechem.physio2
## gives same results

```


## Now see partiontion of variance:
Now 4 component:
Conditioned:amount of variances explained by covariables and removed 
--what are the covariables
Contrained- amount of variance uniquely explained by explanatory variables
Unconstrained: residual variance
NOTE: proportions are unadjusted and need to be adjusted using permutations. 


```{r}
anova.cca(spechem.physio2, step=1000)
anova.cca(spechem.physio2, step=1000, by="axis")
## see that the first two axes are significant

## partial RDA triplots

#Scaling 1
plot(spechem.physio, scaling=1, display=c("sp", "lc", "cn"), 
     main="Triplot RDA spe.hel ~chem | Top =scaling1 -1c scores")
spe3.sc <- scores(spechem.physio, choices=1:2, scaling=1, display="sp")
arrows(0,0, spe3.sc[,1], spe3.sc[,2], length=0, lty=1, col="red")

## Scaling 2

plot(spechem.physio, scaling=2, display=c("sp", "lc", "cn"), 
     main="Triplot RDA spe.hel ~chem | Top =scaling2 -1c scores")
spe4.sc <- scores(spechem.physio, choices=1:2, display="sp")
arrows(0,0, spe4.sc[,1], spe4.sc[,2], length=0, lty=1, col="red")


```
The interpretation is quite interesting, but I am quite anxious to get on to the variance partitioning


#### 6.3.2.6 Forward selection of explanatory variables

-could want to reduce variables because they are highly correlated

-examine VIF-variance inflation factors- measure proportion by which variance of a regression coefficient is inflated in the presence of explanatory variables. 

-VIFs above 20 indicate strong collinearity, VIFs above 10 should be examined and avoided if possible

```{r}
## Variance  inflation factors (VIF) in two RDAs

## first RDA of the chapter : all environmental variables
vif.cca(spe.rda)
vif.cca(spechem.physio)

```


## Forward selection using a Dray et al 2007 packaged `packfor`

```{r}
## does not allow factor variables
spe.rda.all <- rda(spe.hel ~ .,data=env)
#global adjusted R2
(R2a.all <- RsquareAdj(spe.rda.all)$adj.r.squared)
# Forward selection using packfor's forward.sel()
library(packfor)
forward.sel(spe.hel, env, adjR2thresh=R2a.all)
## so last one is the one that violates the threshhold, so it is not included. 

```



Another way to do it. 


```{r}
## Vegan's ordistep()
step.forward <- ordistep(rda(spe.hel ~ 1, data=env),
scope=formula(spe.rda.all), direction="forward", pstep=1000)
```

Have to manually compute R2
```{r}

RsquareAdj(rda(spe.hel ~ alt, data=env))$adj.r.squared
RsquareAdj(rda(spe.hel ~ alt+oxy, data=env))$adj.r.squared
RsquareAdj(rda(spe.hel ~ alt+oxy+bdo, data=env))$adj.r.squared
RsquareAdj(rda(spe.hel ~ alt+oxy+bdo+har, data=env))$adj.r.squared
```


So then do a parsimonious RDA
with the selected variables
```{r}
spe.rda.pars <- rda(spe.hel~alt+oxy+bdo, data=env)
spe.rda.pars
anova.cca(spe.rda.pars, step=1000)
anova.cca(spe.rda.pars, step=1000, by="axis")
vif.cca(spe.rda.pars)

(R2a.pars <- RsquareAdj(spe.rda.pars)$adj.r.squared)

```


 Now look at these model vs the global model.
 
 
```{r}
# scaling 1
plot(spe.rda.pars, scaling=1, display=c("sp", "lc", "cn"),
     main="Triplot  RDA spe.hel ~alt+oxy+bdo - scaling 1 - lc scores")
spe4.sc <- scores(spe.rda.pars, choices=1:2, scaling=1, display="sp")
arrows(0,0, spe4.sc[,1], spe4.sc[,2], length=0, lty=1, col="red")

# scaling 2
plot(spe.rda.pars,  display=c("sp", "lc", "cn"),
     main="Triplot  RDA spe.hel ~alt+oxy+bdo - scaling 2 - lc scores")
spe5.sc <- scores(spe.rda.pars, choices=1:2,  display="sp")
arrows(0,0, spe5.sc[,1], spe5.sc[,2], length=0, lty=1, col="red")

```

## Variation partitioning

```{r}
## Variation partionoin with 2 sets of explanatory variables

# Fraction labels
showvarparts(2) # 2 explanotry labels
showvarparts(3) # 3 expla
showvarparts(4) #4

## variation partitionign with all explanatory variables
spe.part.all <- varpart(spe.hel, envchem, envtopo)
spe.part.all
plot(spe.part.all, digits=2)
## so it seems that the variables are intercorrelated so a good reason to do parsimony and combine variation partiionaing iwth forward selection.
```

```{r}
## Separate forward selection in each subset of environmental variables

spe.chem <- rda(spe.hel, envchem)
R2a.all.chem <- RsquareAdj(spe.chem)$adj.r.squared
forward.sel(spe.hel, envchem, adjR2thresh = R2a.all.chem, nperm=9999)

spe.topo <- rda(spe.hel, envtopo)
R2a.all.topo <- RsquareAdj(spe.topo)$adj.r.squared
forward.sel(spe.hel, envtopo, adjR2thresh=R2a.all.topo, nperm=9999)

#parsimonioius subsets of explanatory variables(based on forward selections)
envchem.pars <- envchem[,c(4,6,7)]
envtopo.pars <- envtopo[,c(1,2)] ## but this doesn't quite make sense because it was only 1. I will redo with only 1
envtopo.pars <- envtopo[,c(1)] 

## Variation partitioning
(spe.part <- varpart(spe.hel, envchem.pars, envtopo.pars))
plot(spe.part, digits=2)

## so this didn't really do anything....still similar result
## Tests

anova.cca(rda(spe.hel, envchem.pars),step=1000)
anova.cca(rda(spe.hel, envtopo.pars),step=1000)
env.pars <- cbind(envchem.pars, envtopo.pars)
anova.cca(rda(spe.hel, env.pars),step=1000)
anova.cca(rda(spe.hel, envchem.pars, envtopo.pars),step=1000)
anova.cca(rda(spe.hel,  envtopo.pars, envchem.pars),step=1000)
```


## What if we remove the nit variable

```{r}
envchem.pars2 <- envchem[,c(6,7)]
(spe.part2 <- varpart(spe.hel, envchem.pars2, envtopo.pars))
plot(spe.part2, digits=2)

```


